<!DOCTYPE html>
<html lang="ko-KR">
  <head>
    <meta name="theme-color" content="#59a1de"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title>프로그래밍 권장사항 | PEP8 한국어 번역</title><meta name="description" content="PEP8을 한국어로 번역한 결과물이 담겨있는 문서사이트입니다."><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="VuePress 2.0.0-beta.14">
    <link rel="preload" href="/pep8-in-korean/assets/js/runtime~app.c5d64ffa.js" as="script"><link rel="preload" href="/pep8-in-korean/assets/css/styles.bf925457.css" as="style"><link rel="preload" href="/pep8-in-korean/assets/js/754.f73b4133.js" as="script"><link rel="preload" href="/pep8-in-korean/assets/js/app.619ecbb1.js" as="script">
    <link rel="stylesheet" href="/pep8-in-korean/assets/css/styles.bf925457.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><header class="navbar"><div class="toggle-sidebar-button"><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class=""></path></svg></div><span><a href="/pep8-in-korean/" class=""><!----><span class="site-name">PEP8 한국어 번역</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/pep8-in-korean/docguide/" class="nav-link" aria-label="Guide"><!--[--><!--]--> Guide <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/pep8-in-korean/doc/" class="nav-link router-link-active" aria-label="Document"><!--[--><!--]--> Document <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/pep8-in-korean/hello/" class="nav-link" aria-label="Hello"><!--[--><!--]--> Hello <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/zerosheepmoo/pep8-in-korean" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><div class="search-box"><input placeholder="Search" autocomplete="off" spellcheck="false" value><!----></div></div></header><div class="sidebar-mask"></div><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/pep8-in-korean/docguide/" class="nav-link" aria-label="Guide"><!--[--><!--]--> Guide <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/pep8-in-korean/doc/" class="nav-link router-link-active" aria-label="Document"><!--[--><!--]--> Document <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/pep8-in-korean/hello/" class="nav-link" aria-label="Hello"><!--[--><!--]--> Hello <!--[--><!--]--></a></div><div class="navbar-links-item"><a class="nav-link external" href="https://github.com/zerosheepmoo/pep8-in-korean" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><section class="sidebar-group"><p class="sidebar-heading active">PEP8</p><ul class=""><li><!--[--><a href="/pep8-in-korean/doc/introduction.html" class="nav-link sidebar-link" aria-label="소개"><!--[--><!--]--> 소개 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/pep8-in-korean/doc/a-foolish-consistency-is-the-hobgoblin-of-little-minds.md" class="nav-link sidebar-link" aria-label="각선구검"><!--[--><!--]--> 각선구검 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/pep8-in-korean/doc/code-lay-out.html" class="nav-link sidebar-link" aria-label="코드 레이아웃"><!--[--><!--]--> 코드 레이아웃 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/pep8-in-korean/doc/string-quotes.html" class="nav-link sidebar-link" aria-label="문자열 쿼트"><!--[--><!--]--> 문자열 쿼트 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/pep8-in-korean/doc/whitespace-in-expressions-and-statements.html" class="nav-link sidebar-link" aria-label="표현과 문장에서의 공백"><!--[--><!--]--> 표현과 문장에서의 공백 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/pep8-in-korean/doc/when-to-use-trailing-commas.html" class="nav-link sidebar-link" aria-label="후행 쉼표를 사용할 경우"><!--[--><!--]--> 후행 쉼표를 사용할 경우 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/pep8-in-korean/doc/comments.html" class="nav-link sidebar-link" aria-label="주석"><!--[--><!--]--> 주석 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/pep8-in-korean/doc/naming-conventions.html" class="nav-link sidebar-link" aria-label="작명 컨벤션"><!--[--><!--]--> 작명 컨벤션 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/pep8-in-korean/doc/programming-recommendations.html" class="router-link-active router-link-exact-active nav-link router-link-active sidebar-link active" aria-label="프로그래밍 권장사항"><!--[--><!--]--> 프로그래밍 권장사항 <!--[--><!--]--></a><ul class="sidebar-sub-headers"><li><!--[--><a aria-current="page" href="/pep8-in-korean/doc/programming-recommendations.html#함수-어노테이션" class="router-link-active router-link-exact-active nav-link sidebar-link" aria-label="함수 어노테이션"><!--[--><!--]--> 함수 어노테이션 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/pep8-in-korean/doc/programming-recommendations.html#변수-어노테이션" class="router-link-active router-link-exact-active nav-link sidebar-link" aria-label="변수 어노테이션"><!--[--><!--]--> 변수 어노테이션 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a href="/pep8-in-korean/doc/copyright.html" class="nav-link sidebar-link" aria-label="저작권"><!--[--><!--]--> 저작권 <!--[--><!--]--></a><!----><!--]--></li></ul></section><!--]--><!--]--></ul><!--[--><!--]--></aside><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="프로그래밍-권장사항"><a class="header-anchor" href="#프로그래밍-권장사항">#</a> 프로그래밍 권장사항</h1><ul><li><p>코드는 Python 의 다른 구현들 (PyPy, Jython, IronPython, Cython, Psyco 등) 에 해가 되지 않는 방향으로 작성되어야 한다.</p><p>예를 들면, <code>a += b</code> 또는 <code>a = a + b</code> 형식의 명령문에 대한 CPython의 효율적인 내부 문자열 연결(concatenation) 구현에 의존하지 말자. 이 최적화는 CPython 에서도 깨지기 쉽다. (이는 몇몇 타입에만 작동한다.) 그리고 refcounting<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>을 사용하지 않는 구현에는 이러한 최적화가 없다. 라이브러리의 성능에 민감한 부분에서는 <code>&#39;&#39;.join ()</code> 형식을 대신 사용해야 한다. 이렇게 하면 다양한 구현에서 연결이 선형 시간으로 발생한다.</p></li><li><p><code>None</code> 같은 싱글톤과의 비교는 <code>is</code> 나 <code>is not</code> 으로 항상 이루어져야 한다. 등호 연산자는 절대 안 된다.</p><p>또, <code>if x</code> 를 작성할 때는 정말로 <code>if x is not None</code> 의 의미여야 한다. 예를 들면, None 이 디폴트 값으로 설정된 변수 또는 인수가 다른 값으로 설정되었는지 여부를 테스트 할 때가 있다. 그 다른 값은 boolean 컨텍스트에서 false 가 될 수 있는 타입을 갖고 있을 수 있다! (container 같이)</p></li><li><p><code>is not</code> 연산자를 <code>not ... is</code>보다 더 사용하자. 둘 다 기능적으로는 동일하지만, 전자의 형식이 더 가독성 있고 바람직한 방식이다.</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 옳은 예:</span>
<span class="token keyword">if</span> foo <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 잘못된 예:</span>
<span class="token keyword">if</span> <span class="token keyword">not</span> foo <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li><li><p>리치 연산자를 사용하여 연산자의 순서를 정하는 구현을 할 때, 여섯 개의 모든 연산자 (<code>__eq__</code>, <code>__ne__</code>, <code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, <code>__ge__</code>) 를 구현하는 것이 가장 좋다. 특정 연산에서 작동하는 다른 코드에 의존하는 것보다 말이다.</p><p>들어가는 노력을 최소화하기 위해, <code>functools.total_ordering()</code> 데코레이터는 누락된 비교 메소드를 생성하는 툴을 제공한다.</p><p><a href="https://www.python.org/dev/peps/pep-0207/" target="_blank" rel="noopener noreferrer">PEP 207<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 은 반사성(reflexivity) 규칙이 Python 에 의해 <strong>가정</strong>됨을 나타낸다. 따라서, 인터프리터가 <code>y &gt; x</code> 를 <code>x &lt; y</code>로, <code>y &gt;= x</code> 를 <code>x &lt;= y</code>로 바꾸거나, <code>x == y</code> 와 <code>x != y</code>의 아규먼트(<em>역: 여기서는 양변</em>)을 바꿀 수 있다. <code>sort()</code>와 <code>min()</code> 연산은 <code>&lt;</code> 연산자를 사용하는 것을, <code>max()</code> 함수는 <code>&gt;</code> 연산자를 사용하는 것을 보장한다. 하지만, 다른 컨텍스트로부터 혼란이 떠오르지 않기 위해 여섯 개의 모든 연산들을 구현하는 것이 가장 바람직하다.</p></li><li><p>식별자에 직접적으로 람다 표현식을 바인딩한 할당문보다, 항상 <code>def</code> 문을 사용하자.</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>      <span class="token comment"># 옳은 예:</span>
      <span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token operator">*</span>x
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>      <span class="token comment"># 잘못된 예:</span>
      f <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token number">2</span><span class="token operator">*</span>x
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>첫번째 형식은 결과 함수 객체명을 제네릭 <code>&lt;lambda&gt;</code> 대신 구체적으로 &#39;f&#39;임을 의미한다. 이는 일반적인 문자열 표현(representation)과 역추적(tracebacks)에 있어 유용하다. 할당문을 사용하면 람다 표현식이 명시적 <code>def</code> 선언문에 비해 제공할 수 있는 유일한 이점을 잃는다. (즉, 커다란 표현 안에서 내장될(embedded) 수 있다는 이점)</p></li><li><p>예외를 <code>BaseException</code>보다 <code>Exception</code>으로부터 파생(derive)시키자. <code>BaseException</code>으로부터 직접적인 상속을 한 예외는 대게 항상 잘못된 짓을 했을 때 포착(catching)되는 예외가 있는 곳에서 사용될 것으로 예정되어있다.</p><p>코드가 예외를 <em>포착</em>하는 데 필요한 구분(distictions)을 기반으로 예외 계층을 설계하자. 예외가 떠오르는(raised) 곳에서 하기보다는 말이다. 단순히 &quot;문제가 발생하였다.&quot;는 언급에 대하여 겨냥하기 보단, 프로그램적으로 &quot;무엇이 잘못 되어가고 있었나?&quot; 하는 질문에 대한 답을 겨냥하자. (<a href="https://www.python.org/dev/peps/pep-3151/" target="_blank" rel="noopener noreferrer">PEP 3151<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 의 내장 예외 계층에 대해서 배우는 수업의 예시를 참고하자.)</p><p>비록 예외가 오류일 경우에는 접두어로 &quot;Error&quot;를 당신의 예외 클래스들에 추가하지만, 기본적으로 <a href="/pep8-in-korean/doc/naming-conventions.html#%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3%E1%84%86%E1%85%A7%E1%86%BC" class="">클래스 작명 컨벤션</a>이 적용된다. 에러가 아닌 예외들은 특별한 접두어가 필요하지 않다. 이런 예외들은 비논리적인 흐름 제어거나 다른 신호전달(signaling)의 형태다.</p></li><li><p>예외 체이닝을 적절히 사용하자. Python 3에서는 <code>raise X from Y</code>가 원래의 역추적(traceback)의 손실 없이 명시적인 대체(<em>역: 예외 체이닝</em>)를 나타내는데 사용되어야한다.</p><p>의도적으로 내부 예외를 대체하는 경우 (Python 2의 <code>raise X</code>, Python 3.3+의 <code>raise X from Y</code>를 사용하는 것), 관련 세부 사항이 새로운 예외로 양도(transferred)되었다는 것을 보장해야한다. (예를 들어, KeyError를 AttributeError로 전환할 때 어트리뷰트명이 보존되는 것 또는, 새로운 예외 메시지 안에서 원래 예외의 텍스트가 들어있는 것)</p></li><li><p>Python 2 에서 예외가 떠오를 경우, <code>raise ValueError(&#39;message&#39;)</code>를 사용하자. 오래된 형식인 <code>raise ValueError, &#39;message&#39;</code> 대신에 말이다.</p><p>이 오래된 형식은 Python 3 문법에서는 허용하지 않는다.</p><p>또한, 괄호 사용 양식(paren-using form)은 예외의 아규먼트가 길거나 문자열 포매팅을 포함할 때, 감싸는 소괄호 덕에 줄 이음 문자를 사용할 필요가 없어짐을 나타내기도 한다.</p></li><li><p>예외를 포착할 때, 생 <code>except:</code> 절을 사용하기 보다 가능한 특정 예외를 언급하라.</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token keyword">import</span> platform_specific_module
<span class="token keyword">except</span> ImportError<span class="token punctuation">:</span>
    platform_specific_module <span class="token operator">=</span> <span class="token boolean">None</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>생 <code>except:</code> 절은 SystemExit 과 KeyboardInterrupt 예외를 포착할 것이며, 이로인해 컨트롤 + C 를 사용해서 프로그램을 중단하기 어렵게 만든다. 그리고 다른 문제로 가장(disguise)될 수도 있다. (<em>역: 본래 문제에 대한 예외가 발생해야하는데 다른 문제로 인식될 수 있다는 것</em>) 프로그램 오류를 알리는 모든 예외를 포착하고 싶다면, <code>except Exception:</code>을 사용하자. (생 예외처리는 <code>except BaseException:</code>과 같기 때문이다.)</p><p>엄지척 할 수 있는 좋은 규칙은 생 <code>&#39;except&#39;</code> 절 사용을 다음 두 개의 경우로만 제한하는 것이다.</p><ol><li>예외 핸들러가 역추적을 로깅하거나 출력하게 될 때. 최소한 사용자가 오류가 발생했음을 인지할 수 있도록.</li><li>코드 정리(cleanup) 작업을 해야할 때. 하지만 그럴 땐 예외를 <code>raise</code>와 함께 위로 전파(propagate)하도록 하게하자. 이러한 경우를 제어하기 위해 <code>try..finally</code> 가 더 좋은 방법이 될 수 있다.</li></ol></li><li><p>포착된 예외를 이름에 바인딩할 때, Python 2.6 에서 추가된 명시적 이름 바인딩 구문이 바람직하다.</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token keyword">try</span><span class="token punctuation">:</span>
    process_data<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> Exception <span class="token keyword">as</span> exc<span class="token punctuation">:</span>
    <span class="token keyword">raise</span> DataProcessingFailedError<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>exc<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>이는 Python 3에서만 지원되는 구문이다. 그리고 오래된 콤마 기반 구문과 구분하기 애매해지는 문제를 피하자.</p></li><li><p>운영체제 오류를 포착할 땐, Python 3.3 에서 도입된 명시적 예외 계층구조가 바람직하다. <code>errno</code> 값들을 검사하는 것(introspection) 대신에 말이다.</p></li><li><p>추가적으로 모든 try/except 절에 대해, <code>try</code> 절을 필요한 최소한의 코드로 제한하자. 다시 말하지만, 이는 마스킹 버그를 방지한다.</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 옳은 예:</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    value <span class="token operator">=</span> collection<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token keyword">except</span> KeyError<span class="token punctuation">:</span>
    <span class="token keyword">return</span> key_not_found<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> handle_value<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 잘못된 예:</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token comment"># 너무 범위가 넓다!</span>
    <span class="token keyword">return</span> handle_value<span class="token punctuation">(</span>collection<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> KeyError<span class="token punctuation">:</span>
    <span class="token comment"># handle_value() 로 떠오른 KeyError 도 포착하게 될 것이다.</span>
    <span class="token keyword">return</span> key_not_found<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li><li><p>자원이 특정 구역의 코드에 국지적일 때, <code>with</code> 문을 사용하여 즉시 정리됨과 사용 후 신뢰성(reliably)를 보장하자. try/finally 문 또한 허용가능하다.</p></li><li><p>컨텍스트 관리자는 자원을 획득하거나 해제하는 일 외의 작업을 할 때마다 별도의 함수 또는 메소드를 통해 불러와져야(invoked) 한다.</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 옳은 예:</span>
<span class="token keyword">with</span> conn<span class="token punctuation">.</span>begin_transaction<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    do_stuff_in_transaction<span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 잘못된 예:</span>
<span class="token keyword">with</span> conn<span class="token punctuation">:</span>
    do_stuff_in_transaction<span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>후자의 예시는 <code>__enter__</code>와 <code>__exit__</code> 메소드가 트랜잭션(transaction) 후의 연결을 닫는 것 외에 어떤 작업을 수행하고 있음을 나타내는 어떠한 정보도 제공하지 않는다. 이 경우 명시적으로 하는 것이 중요하다.</p></li><li><p>반환문에 대하여 일관성을 지키자. 함수 내 모든 반환문은 표현을 반환하거나 어떤 것도 반환하지 않아야 한다. 만약 반환문이 어떠한 표현을 반환한다면, 어떠한 반환문도 반환값이 없는 곳에서는 명시적으로 <code>return None</code>을 작성해야 한다. 그리고 명시적인 반환문은 함수의 끝에 나타내야 한다. (도달 가능(reachable)하다면 말이다.)</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 옳은 예:</span>

<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> x <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>

<span class="token keyword">def</span> <span class="token function">bar</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    <span class="token keyword">return</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 잘못된 예:</span>

<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> x <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>x<span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">bar</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    <span class="token keyword">return</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li><li><p>문자열 모듈을 사용하는 것 대신에 문자열 메소드를 사용하자.</p><p>문자열 메소드는 항상 더 빠르고 유니코드 문자열과 같은 API를 공유한다. 2.0 버전 혹은 이전버전의 Python과 하위 호환성이 필요한 경우, 이 규칙을 오버라이딩 하자.</p></li><li><p>접두어나 접미어를 확인할 때는, 문자열 슬라이싱 대신에 <code>&#39;&#39;.startswith()</code>와 <code>&#39;&#39;.endswith()</code>를 사용하자.</p><p><code>startswith()</code> 와 <code>endswith()</code>는 더 간결하고 오류를 적게 발생시킨다.</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 옳은 예:</span>
<span class="token keyword">if</span> foo<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">&#39;bar&#39;</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 잘못된 예:</span>
<span class="token keyword">if</span> foo<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">&#39;bar&#39;</span><span class="token punctuation">:</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li><li><p>오브젝트 타입 비교는 직접 비교하기 보단,</p></li><li><p>항상 <code>isinstance()</code>를 사용해야한다.</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 옳은 예:</span>
<span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 잘못된 예:</span>
<span class="token keyword">if</span> <span class="token builtin">type</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token keyword">is</span> <span class="token builtin">type</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>오브젝트가 문자열인지를 확인할 때는, 유니코드 문자열일 수도 있다는 점을 명심하자! Python 2에서는 str과 유니코드가 공통적인 기반 클래스, basestring을 가진다. 그래서 다음과 같이 할 수도 있다.</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token builtin">basestring</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Python 3 에서는 더 이상 <code>unicode</code>와 <code>basestring</code>이 존재하지 않는 점을 알아두자. (오직 <code>str</code>만이 있다.) 그리고 바이트 오브젝트는 더 이상 문자열 종류가 아니다. (대신 정수형의 시퀀스(sequence of integers)가 되었다.)</p></li><li><p>시퀀스에 대해서는 (문자열, 리스트, 튜플), 빈 시퀀스가 false 라는 사실을 이용하자.</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 옳은 예:</span>
<span class="token keyword">if</span> <span class="token keyword">not</span> seq<span class="token punctuation">:</span>
<span class="token keyword">if</span> seq<span class="token punctuation">:</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 잘못된 예:</span>
<span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">len</span><span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token punctuation">:</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p>문자열 리터럴을 중요한 후행 공백에 의존하여 작성하지 말자. 그러한 후행 공백은 보기에 구분이 어렵고, 몇 에디터(또는 더 최근의, reindent.py)에서는 트림된다.</p></li><li><p>불린 값을 <code>==</code>를 사용하여 True 또는 False 와 비교하지 말자.</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 옳은 예:</span>
<span class="token keyword">if</span> greeting<span class="token punctuation">:</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 잘못된 예:</span>
<span class="token keyword">if</span> greeting <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>더 안 좋게는 다음과 같이 할 수 있다.</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 잘못된 예:</span>
<span class="token keyword">if</span> greeting <span class="token keyword">is</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li><li><p><code>return</code>/<code>break</code>/<code>continue</code>의 흐름 제어문이 finally 슈트 밖으로 점프될 수 있는 <code>try...finally</code>의 finally 슈트에서의 흐름 제어문들의 사용은 권장하지 않는다. 왜냐하면 이러한 명령문들은 finally 슈트를 통하여 전파된 어떤 활성화 된 예외도 암시적으로 취소할 수 있기 때문이다.</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 잘못된 예:</span>
<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span>
    <span class="token keyword">finally</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">42</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li></ul><h2 id="함수-어노테이션"><a class="header-anchor" href="#함수-어노테이션">#</a> 함수 어노테이션</h2><p><a href="https://www.python.org/dev/peps/pep-0484" target="_blank" rel="noopener noreferrer">PEP 484<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 의 승인으로 함수 어노테이션에 대한 스타일 규칙들이 바뀌고 있다.</p><ul><li><p>상위 호환성을 만족시키기 위해, Python3 의 함수 어노테이션은 가급적 <a href="https://www.python.org/dev/peps/pep-0484" target="_blank" rel="noopener noreferrer">PEP 484<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 의 문법을 사용하여야 한다. (앞선 내용에서 어노테이션을 위한 포매팅 권장사항이 몇 가지 있다.)</p></li><li><p>이 PEP에서 이전에 권장되었던 어노테이션 스타일에 대한 실험적인 시도들은 더 이상 권장되지 않는다.</p></li><li><p>단, 이제는 표준라이브러리(stdlib)를 제외하고, <a href="https://www.python.org/dev/peps/pep-0484" target="_blank" rel="noopener noreferrer">PEP 484<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 규칙에 따른 실험적인 시도를 권장한다. 예를 들면, PEP 484 스타일 유형 어노테이션을 사용하는 대규모 서드 파티 라이브러리나 어플리케이션을 마크 업 하는 것, 이러한 주석을 추가하는 것이 얼마나 쉬운 지 검토하는 것, 그리고 어노테이션의 존재가 코드 이해도를 높이는지 관찰하는 것이 있다.</p></li><li><p>Python 표준 라이브러리는 그러한 어노테이션을 적용하는데 있어 보수적이어야 하지만, 이러한 어노테이션의 사용은 새로운 코드나 대규모 리팩토링에 대해선 허용되어야 한다.</p></li><li><p>함수 어노테이션의 사용에 차이를 두기를 원하는 코드에서, 다음의 형태의 주석을 넣는 것이 권장된다.</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># type: ignore</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>파일 상단에 작성된 이것은 타입 체커에게 모든 어노테이션을 무시해야함을 알려준다. (타입 체커들의 불만을 비활성화시키는 더 자세한 방법은 <a href="https://www.python.org/dev/peps/pep-0484" target="_blank" rel="noopener noreferrer">PEP 484<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 에서 찾을 수 있다.)</p></li><li><p>린터들과 마찬가지로 타입체커는 선택사항이며, 별도의 도구이다. 기본적으로 Python 인터프리터는 타입 체킹으로 어떠한 메시지도 발행하지 않아야 하며, 어노테이션을 기반으로 행위(behavior)를 변경하지 않아야 한다.</p></li><li><p>타입 체커를 사용하지 않으려는 사용자는 자유롭게 무시해도 된다. 하지만, 외부 라이브러리 패키지의 사용자는 해당 패키지의 타입 체커를 실행하길 원할 수도 있다. 이를 목적으로, PEP 484 는 스텁(stub) 파일들의 사용을 권장한다. 이 스텁 파일은 .pyi 파일로, 이에 상응하는 .py 파일들의 설정(preferences)의 타입체커에 의해 읽혀지는 파일이다. 스텁 파일은 라이브러리로 배포되거나, 별도로 (라이브러리 작성자의 권한하에) typeshed 저장소<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>를 통해 배포될 수 있다.</p></li><li><p>하위 호환이 필요한 코드의 경우, 타입 어노테이션은 주석의 형태로 추가될 수 있다. <a href="https://www.python.org/dev/peps/pep-0484/" target="_blank" rel="noopener noreferrer">PEP 484<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>의 관련 섹션을 참조.</p></li></ul><h2 id="변수-어노테이션"><a class="header-anchor" href="#변수-어노테이션">#</a> 변수 어노테이션</h2><p><a href="https://www.python.org/dev/peps/pep-0008/#variable-annotations" target="_blank" rel="noopener noreferrer">PEP528<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 은 변수 어노테이션들을 소개한다. 변수 어노테이션에 대한 권장사항들은 위에서 묘사된 함수 주석과 유사하다.</p><ul><li><p>모듈 레벨의 변수, 클래스와 인스턴스 변수, 그리고 로컬 변수 어노테이션은 콜론 다음에 한 칸 공백이 있어야한다.</p></li><li><p>콜론 앞에는 공백이 없어야 한다.</p></li><li><p>만약 할당식이 우항을 갖고 있다면, 등호 기호는 앞뒤로 정확히 한 칸 공백이 있어야 한다.</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 옳은 예:</span>
code<span class="token punctuation">:</span> <span class="token builtin">int</span>

<span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">:</span>
    coords<span class="token punctuation">:</span> Tuple<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">]</span>
    label<span class="token punctuation">:</span> <span class="token builtin">str</span> <span class="token operator">=</span> <span class="token string">&#39;&lt;unknown&gt;&#39;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token comment"># 잘못된 예:</span>

code<span class="token punctuation">:</span><span class="token builtin">int</span>  <span class="token comment"># 콜론 뒤에 공백이 없다.</span>
code <span class="token punctuation">:</span> <span class="token builtin">int</span>  <span class="token comment"># 콜론 전에 공백이 있다.</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">:</span>
    result<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token operator">=</span><span class="token number">0</span>  <span class="token comment"># 등호(=)를 공백으로 감싸지 않았다.</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li><li><p><a href="https://www.python.org/dev/peps/pep-0008/#variable-annotations" target="_blank" rel="noopener noreferrer">PEP528<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 이 Python 3.6 에서 허용된다고 해도, 변수 어노테이션 구문은 모든 버전의 스텁(stub) 파일들에 적합한 구문이다. (<a href="https://www.python.org/dev/peps/pep-0484/" target="_blank" rel="noopener noreferrer">PEP484<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> 를 참고)</p></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://en.wikipedia.org/wiki/Reference_counting" target="_blank" rel="noopener noreferrer">참조 횟수 계산 방식<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>typeshed 저장소 <a href="https://github.com/python/typeshed" target="_blank" rel="noopener noreferrer">https://github.com/python/typeshed<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>Python 2.7 및 양립 가능 코드(straddling code)를 위한 문법 제안 <a href="https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code" target="_blank" rel="noopener noreferrer">https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><span class="meta-item-info">5/27/2021, 12:57:51 AM</span></div><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"> ← <a href="/pep8-in-korean/doc/naming-conventions.html" class="nav-link" aria-label="작명 컨벤션"><!--[--><!--]--> 작명 컨벤션 <!--[--><!--]--></a></span><span class="next"><a href="/pep8-in-korean/doc/copyright.html" class="nav-link" aria-label="저작권"><!--[--><!--]--> 저작권 <!--[--><!--]--></a> → </span></p></nav><!--[--><!--]--></main></div><!----><!--]--></div>
    <script src="/pep8-in-korean/assets/js/runtime~app.c5d64ffa.js" defer></script><script src="/pep8-in-korean/assets/js/754.f73b4133.js" defer></script><script src="/pep8-in-korean/assets/js/app.619ecbb1.js" defer></script>
  </body>
</html>
